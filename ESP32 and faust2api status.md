# DSP On the ESP32 with Faust  
## faust2api script for ESP32 under ESP-IDF (intermediate results status: 211005 )  

This document is intended for consolidation of the intermediate status on using the faust2api script for ESP32.
A working basic example app is available (example_faust_mqtt_tcp4_v3). The example:  
- has been created for compilation under ESP-IDF
- is based on the Faust elecGuitarMidi.dsp sound engine (currently tests of example_faust_mqtt_tcp5_v1 are ongoing using WaveSynth_FX.dsp)
- has been tested on a TTGO TAudio board 

To get the example working we had to:

- tune ESP-IDF project settings using idf.py menuconfig
- use specific commands for compilation
- modify the DspFaust.cpp file generated by compilation of the elecGuitarMidi.dsp engine with the faust2api script

This document contains a:
1. general description of the example
2. walkthrough on how to use this example under ESP-IDF  
3. walkthrough for creation of a project based on this example with a different Faust sound engine 
4. description of the ESP-IDF project settings and their rationale
5. description of the modifications to the DspFaust.cpp file
 
In the future the faust2api script may have to be adapted for use with an ESP32. As the current status is premature, adaptation of the faust2api script is not yet part of the work until now. Focus is on getting things running.
 
The adaptations in the  DspFaust.cpp file may be specific for the used sound engine and usage environment.
 
Any changes implemented during write up of this consolidation are done in ESP-IDF project faust_mqtt_tcp5_v1

## 1. General description of the example

The example uses the the output generated by the faust2api script for the chosen sound engine (elecGuitarMIDI). The WM8978 audio codec driver files are used unmodified. The DspFaust.cpp file has been modified to get things working. This specifically concerns (parts of) the MIDI configuration. Some of these these modifications may have to be implemented later in the faust2api script for ESP32.

The example contains a main C++ app where the WM8978 audio codec and sound engine are initiated and started in the same way as described in the tutorial on [DSP on the ESP32 With Faust](https://faustdoc.grame.fr/tutorials/esp32/). In addition the app provides connectivity to a WIFI network and an MQTT broker. This is useful for testing the Faust API, but can also be used for future aplications. MQTT can be used to send Faust API commands to the board and receive UI information. Sending and receiving MQTT messages is operational. A very premature version of an API command dispatcher is present. After startup, the app plays a tune (routine: play_rtttl(song, DSP) which uses the DSP->setParamValue API command).  

 
## 2. Walkthrough on how to use the example_faust_mqtt_tcp4_v3 under ESP-IDF  

The example must be compiled in the ESP-IDF environment as a C++ app. To this end the project folder contains a folder main with a main.cpp file (only for this aspect see the praragraph "Starting a New ESP32 Project" in the tutorial on [DSP on the ESP32 With Faust](https://faustdoc.grame.fr/tutorials/esp32/).


1. copy the project folder ("example_faust_mqtt_tcp4_v3") into a suitable location ("path_to_projects") on your computer: 
2. create a secrets.h file in the folder "main"  of the project: <path_to_projects>/example_faust_mqtt_tcp4_v3/main/secrets.h (note 1.)  
3. open an ESP-IDF 4.2 Powershell session in Windows Terminal (see note 2.)
4. move to the root folder of the project (cd <path_to_projects>/example_faust_mqtt_tcp4_v3)
5. set ESP32 as the target hardware with "idf.py set-target ESP32" (Option, not required for using the ready-to-go example) 
6. if present, remove a build folder with it's contents, either by hand or by issuing a "idf.py fullclean" command
7. tune project settings "idf.py menuconfig" (Option, not required for using the ready-to-go example, may be necessary if you have different hardware)
8. compile/build the project:  "idf.py --no-ccache build"  or "idf.py --no-ccache build > buildlognn.txt" for logging of information
9. inspect firmware size by adding an option "size", "size-files" or "size-components" to the above or use "idf.py size" or "idf.py size > sizelog.txt"
10. flash the firmware: connect the device to a serial port of your computer and "run idf.py --no-ccache -p COMnn flash"
11. monitor the output: "run idf.py --no-ccache -p COMnn monitor"

If you have properly configured an MQTT broker, the board sends some messages during start-up.
You can send messages to the board (topic....).  If these are received, they will appear in your monitor screen.
After connection to WIFI and MQTT broker a tune can be heared over the headphone jacket of the board.

#### Notes:
1. Add the following info to secrets.h: 
   #define SECRET_ESP_WIFI_SSID "yourssid"
   #define SECRET_ESP_WIFI_PASSWORD "yourwifipass"
   #define SECRET_ESP_MAXIMUM_RETRY 5

   #define SECRET_ESP_MQTT_BROKER_URI "mqtt://yourbrokerip:1883"
   #define SECRET_ESP_MQTT_BROKER_USERNAME "yourbrokerusername"
   #define SECRET_ESP_MQTT_BROKER_PASSWORD "yourbrokerpassword"
   #define SECRET_ESP_MQTT_CLIENT_ID "egTTGO_TAudio"

2. When opening, this runs a script that sets relvant environment variables for usage of ESP-IDF. Upon installation of the ESP-IDF environment a link to plain Powershell is created. For more convenience (such as copying and pasting commands) I transfered this to a Windows Terminal session. Windows Terminal can also run a Linux under Windows session, which is useful for using the Faust scripts.   


## 3. Walkthrough for creation of a project based on this example with a different Faust sound engine

ESP-IDF uses CMake for building a project. The use of CMake goes **beyond the scope** of this document. Here we describe a method where the new project re-uses the project structure of the example project, including the CMake files.

1. copy the project folder ("example_faust_mqtt_tcp4_v3") into a suitable location ("path_to_projects") on your computer: 
2. create a secrets.h file in the folder "main"  of the project: <path_to_projects>/example_faust_mqtt_tcp4_v3/main/secrets.h (note 1. above)
3. create a sound engine file either by hand or with the online [Faust IDE](https://faustide.grame.fr/index.html) (see the [ESP32 tutorial](https://faustdoc.grame.fr/tutorials/esp32/)  
4. create the C++ sound engine and driver files (DspFaust.cpp/.h) by compiling the .dsp file with the script: for me under Linux for Windows , within \\wsl$\Ubuntu-20.04\home\fckx\faust\tools\faust2appls
 faust2api -esp32 -nvoices 2 elecGuitarMIDI.dsp -target elecGuitarMIDI. 
5. apply a number of modifications to the DspFaust.cpp file (see xxxxx) 
5. copy the DspFaust.cpp/.h files into the folder "main" of your project. Do NOT change the names. The project assumes DspFaust.cpp/.h as the names.
6. to compile and run your project, now continue with step 3 of section 2. in this document.

(test first with elecGuitarMidi.dsp, includes description of the faust2api options,  changing the DspFaust,  specifically:  MidiMeta::analyse(mono_dsp, midi_sync, nvoices);)
(describe folder project structure, location of sound engine files and MakeLists.txt etc.)
(Then test with different sound engine, e.g. simpleSynth_Analog.dsp or WaveSynth_FX.dsp)

## 4. Description of the ESP-IDF project settings and their rationale
  
ESP-IDF project settings can be modified with the idf.py menuconfig command. The settings are saved in the **sdkconfig** file in the root folder of the project. Here we discuss the settings that were important to get the example running. The safest way to start your own project is to copy the project structure, including the contents of the sdkconfig file.

#### Provisional list of relevant project settings  
- disable WIFI speed optimization purpose:  reduce memory usage
- run WIFI code on CPU 1 purpose: prevent interference (clicks) with sound engine
- similar changes with MQTT
- use external RAM
- enable/disable C++ exceptions (necessity has been removed by commenting a throw ..... in the DspFaust file.
- enable/disable C++ rtti
- (do a file compare of the Hello World or early faust2api sdkconfig with the example SDK config to detect more differences)
- 

 

## 4. Description of modifications to the DspFaust.cpp file (case faust2api <options> elecGuitarMIDI.dsp  ) 

** NOTE ** all of these adaptations can be REVERTED. only c. (bad_alloc) is necesssary, PROVIDED that the jdksmidi lib .h files and their corresponding .cpp files mentioned under e. are placed in the main folder AND in a folder jdksmidi in main. I will investigate which of the two locations is essential at the current project settings. A solution might be in correct project settings.
 
 ** NOTE 2 ** These files must be taken from the Thomas Hofman hack of the original jdksmidi lib, for reasons that are unclear to me.
 
 
 a. comment the call MidiMeta::analyses  appr line nr 11928 (for elecGuitarMIDI)  
      NOTE: addition of nvoices = NVOICES;
                                  midi_sync = true;  
    to simulate the output of MidiMeta::analysis leads to a stack overflow error 
 
 
 b. comment static void analyses line 9111 - 9147
 
 c. comment throw std:: bad_alloc()  line 25276 (to allow C++ exceptions)  near  printf("You are not setting 'sample_rate' and 'buffer_size', but the audio driver needs it !\n");
   There are two additional occurrences of this code , these are still in. These are probably not active because of compilation directives.
 
 d. added #include esp_log.h ~ line 45 to add logging functionality
 
 e. added includes for the jdksmidi lib files:
``` 
 #elif FCKXMIDI

//using namespace jdksmidi;
typedef unsigned char uchar;  //world.h

#include "world.h"
#include "midi.h"
#include "msg.h"
#include "sysex.h"
#include "parser.h"

#endif
```
 
These files are added to the main folder AND the jdksmidi folder and were taken from the repo of Thomas Hopman (Hofman?) You should use his lib and NOT the original lib. Inclusion for both libs is not (yet) successful with my project setup. Therefore I applied this dirty trick.....

 f. relationg to this some changes (to be described) near line 18927....
 
 
 
 NOTE: the changes a. and b. can be undone when the ESP32 main stack size is increased in the project settings (idf.py menuconfig).  Default: 3584. Now 14336 (factor of 4). Later this "huge" increase will have to be minimized as total firmware size may become critical.   
