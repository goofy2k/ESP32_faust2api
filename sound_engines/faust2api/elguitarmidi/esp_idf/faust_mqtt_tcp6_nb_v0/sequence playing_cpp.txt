#define isdigit(n) (n >= '0' && n <= '9')

void play_keys(DspFaust * aDSP){  //uses keyOn / keyOff
       // start continuous background voice for testing polyphony
       
       /*
       aDSP->keyOn(50, 126);
       vTaskDelay(3000 / portTICK_PERIOD_MS);
       */
  
        for (int ii = 48; ii < 69; ii++){
        printf("counter ii %d \n",ii);    
        vTaskDelay(100 / portTICK_PERIOD_MS);
        //update_controls(voiceAddress,aDSP)        
        uintptr_t voiceAddress = aDSP->keyOn(ii,126);
        //cannot use update_controls as used here for this kind of voice ?? 
        //update_controls(voiceAddress,aDSP); 
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        //aDSP->setVoiceParamValue(5,voiceAddress,110);
        //update_controls(voiceAddress,aDSP);
        aDSP->setVoiceParamValue("/WaveSynth_FX/freq",voiceAddress,110);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        int res = aDSP->keyOff(ii);
        }  
         vTaskDelay(3000 / portTICK_PERIOD_MS);
         
        /*
        //release continuous background voice
        aDSP->keyOff(50);
        */
}




void play_keys2(DspFaust * aDSP){  //uses keyOn / keyOff
       // start continuous background voice
       
      
       aDSP->keyOn(50, 126);
       vTaskDelay(3000 / portTICK_PERIOD_MS);
/*       
       //release continuous background voice
       //aDSP->keyOff(50); 
       */
       
        for (int ii = 52; ii < 71; ii++){
        printf("counter ii %d \n",ii);    
        vTaskDelay(100 / portTICK_PERIOD_MS);    
        uintptr_t voiceAddress = aDSP->keyOn(ii,126);
        //cannot use update_controls as used here for this kind of voice 
        //update_controls(voiceAddress,aDSP); 
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        //aDSP->setVoiceParamValue(5,voiceAddress,110);
        aDSP->setVoiceParamValue("/WaveSynth_FX/freq",voiceAddress,110);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        int res = aDSP->keyOff(ii);
        
        }  
         vTaskDelay(3000 / portTICK_PERIOD_MS);
        
        //release continuous background voice
        aDSP->keyOff(50);
        
}


void play_setVoiceParam_path(DspFaust * aDSP) 
{ //uses setVoiceParamValue(path

/*
    uintptr_t bg_voiceAddress = aDSP->newVoice(); //create background voice    
    aDSP->setVoiceParamValue("/WaveSynth_FX/gain",bg_voiceAddress,1);  
    aDSP->setVoiceParamValue("/WaveSynth_FX/freq",bg_voiceAddress,110.0);
    // aDSP->setVoiceParamValue("/WaveSynth_FX/freq",freqs[(scale-4) * 12 + note]);
    aDSP->setVoiceParamValue("/WaveSynth_FX/gate",bg_voiceAddress,1.0);
    vTaskDelay(500 / portTICK_PERIOD_MS);  
*/


    uintptr_t voiceAddress = aDSP->newVoice(); //create main voice    
    aDSP->setVoiceParamValue("/WaveSynth_FX/gain",voiceAddress,1);
    
        for (int ii = 50; ii < 100; ii++){
           update_controls(voiceAddress,aDSP);  
           aDSP->setVoiceParamValue("/WaveSynth_FX/freq",voiceAddress,440.0);
           // aDSP->setVoiceParamValue("/WaveSynth_FX/freq",freqs[(scale-4) * 12 + note]);
           aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,1.0);
           vTaskDelay(500 / portTICK_PERIOD_MS);          
           aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,0);
           vTaskDelay(500 / portTICK_PERIOD_MS); 
           
           update_controls(voiceAddress,aDSP);  
           aDSP->setVoiceParamValue("/WaveSynth_FX/freq",voiceAddress,220.0);
           // aDSP->setVoiceParamValue("/WaveSynth_FX/freq",freqs[(scale-4) * 12 + note]);
           aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,1);
           vTaskDelay(500 / portTICK_PERIOD_MS);          
           aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,0);
           vTaskDelay(500 / portTICK_PERIOD_MS);
           
           /*
           vTaskDelay(500 / portTICK_PERIOD_MS);          
           aDSP->setVoiceParamValue("/WaveSynth_FX/gate",bg_voiceAddress,0);
           vTaskDelay(500 / portTICK_PERIOD_MS); 
           */
           
        }
           aDSP->deleteVoice(voiceAddress); //delete main voice
  //         aDSP->deleteVoice(bg_voiceAddress); //delete background voice
};

void play_setVoiceParam_Id(DspFaust * aDSP) 
{
ESP_LOGI(TAG, "play_poly_without_midi_Id");

  /*
    //start background voice
    uintptr_t background_voiceAddress = aDSP->newVoice(); //create main voice
    aDSP->setVoiceParamValue(freqId,background_voiceAddress,110.0);
    aDSP->setVoiceParamValue(gainId,background_voiceAddress,0.02);
    ESP_LOGI(TAG, "setVoiceParamValue(freqId,voiceAddress,110) set freq");  //FCKX
    aDSP->setVoiceParamValue(gateId,background_voiceAddress,1);
    ESP_LOGI(TAG, "setVoiceParamValue(gateId,background_voiceAddress,1) GATE ON");  //FCKX
  */
     
    //loop with subsequential triggers on the same voice  
    uintptr_t voiceAddress = aDSP->newVoice(); //create main voice

    for (int ii = 0; ii < 50; ii++){
        
        update_controls(voiceAddress,aDSP);        
        aDSP->setVoiceParamValue(freqBaseId+poly,voiceAddress,440.0);
        ESP_LOGI(TAG, "freqBaseId %d, set freq %6.2f", freqBaseId, 440.0);  //FCKX
        aDSP->setVoiceParamValue(gateBaseId+poly,voiceAddress,1);
        ESP_LOGI(TAG, "gateBaseId %d, set gate %d", gateBaseId, 1);  //FCKX
        vTaskDelay(500 / portTICK_PERIOD_MS); 
        ESP_LOGI(TAG, "delay");  //FCKX
        aDSP->setVoiceParamValue(gateBaseId+poly,voiceAddress,0);
        ESP_LOGI(TAG, "gateBaseId %d, set gate %d", gateBaseId, 0);  //FCKX
        vTaskDelay(500 / portTICK_PERIOD_MS); 
        ESP_LOGI(TAG, "delay");  //FCKX

        update_controls(voiceAddress,aDSP);        
        aDSP->setVoiceParamValue(freqBaseId+poly,voiceAddress,220.0);
        ESP_LOGI(TAG, "setVoiceParamValue(freqBaseId+poly,voiceAddress,440.0)");  //FCKX
        aDSP->setVoiceParamValue(gateBaseId+poly,voiceAddress,1);
        ESP_LOGI(TAG, "gateBaseId %d, set gate %d", gateBaseId, 1);  //FCKX
        vTaskDelay(500 / portTICK_PERIOD_MS); 
        ESP_LOGI(TAG, "delay");  //FCKX
        aDSP->setVoiceParamValue(gateBaseId+poly,voiceAddress,0);
        ESP_LOGI(TAG, "gateBaseId %d, set gate %d", gateBaseId, 0);  //FCKX
        vTaskDelay(500 / portTICK_PERIOD_MS); 
        ESP_LOGI(TAG, "delay");  //FCKX
        
        }

          //release background voice
         // aDSP->setVoiceParamValue(gateId,background_voiceAddress,0);
         // ESP_LOGI(TAG, "setVoiceParamValue(gateId,background_voiceAddress,1) GATE OFF");  //FCKX
          
          //clean up voices
           
          aDSP->deleteVoice(voiceAddress);            //delete main voice 
           
          
       //   aDSP->deleteVoice(background_voiceAddress); //delete background voice  
           
};



void play_poly_rtttl(char *p, DspFaust * aDSP)
{
 // aDSP->allNotesOff(); 

  uintptr_t voiceAddress = aDSP->newVoice(); //create main voice    
  aDSP->setVoiceParamValue("/WaveSynth_FX/gain",voiceAddress,1);
 
 
 update_controls(voiceAddress,aDSP);
 
  aDSP->setVoiceParamValue("/WaveSynth_FX/lfoFreq",voiceAddress,lfoFreq);
  aDSP->setVoiceParamValue("/WaveSynth_FX/lfoDepth",voiceAddress,lfoDepth); 
  aDSP->setVoiceParamValue("/WaveSynth_FX/A",voiceAddress,synthA);
  aDSP->setVoiceParamValue("/WaveSynth_FX/D",voiceAddress,synthD); 
  aDSP->setVoiceParamValue("/WaveSynth_FX/S",voiceAddress,synthS); 
  aDSP->setVoiceParamValue("/WaveSynth_FX/R",voiceAddress,synthR); 
  // Absolutely no error checking in here
  unsigned char default_dur = 4;
  unsigned char default_oct = 6;
  int bpm = 63;
  int num;
  long wholenote;
  long duration;
  unsigned char note;
  unsigned char scale;

  // format: d=N,o=N,b=NNN:
  // find the start (skip name, etc)

  //char * p = song;

  while(*p != ':') p++;    // ignore name
  p++;                     // skip ':'

  // get default duration
  if(*p == 'd')
  {
    p++; p++;              // skip "d="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    if(num > 0) default_dur = num;
    p++;                   // skip comma
  }

 //Serial.print("ddur: "); Serial.println(default_dur, 10);

  // get default octave
  if(*p == 'o')
  {
    p++; p++;              // skip "o="
    num = *p++ - '0';
    if(num >= 3 && num <=7) default_oct = num;
    p++;                   // skip comma
  }

  //Serial.print("doct: "); Serial.println(default_oct, 10);

  // get BPM
  if(*p == 'b')
  {
    p++; p++;              // skip "b="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    bpm = num;
    p++;                   // skip colon
  }

  //Serial.print("bpm: "); Serial.println(bpm, 10);

  // BPM usually expresses the number of quarter notes per minute
  wholenote = (60 * 1000L / bpm) * 4;  // this is the time for whole note (in milliseconds)

  //Serial.print("wn: "); Serial.println(wholenote, 10);


  // now begin note loop
  while(*p)
  {
    // first, get note duration, if available
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    
    if(num) duration = wholenote / num;
    else duration = wholenote / default_dur;  // we will need to check if we are a dotted note after

    // now get the note
    note = 0;

    switch(*p)
    {
      case 'c':
        note = 1;
        break;
      case 'd':
        note = 3;
        break;
      case 'e':
        note = 5;
        break;
      case 'f':
        note = 6;
        break;
      case 'g':
        note = 8;
        break;
      case 'a':
        note = 10;
        break;
      case 'b':
        note = 12;
        break;
      case 'p':
      default:
        note = 0;
    }
    p++;

    // now, get optional '#' sharp
    if(*p == '#')
    {
      note++;
      p++;
    }

    // now, get optional '.' dotted note
    if(*p == '.')
    {
      duration += duration/2;
      p++;
    }
  
    // now, get scale
    if(isdigit(*p))
    {
      scale = *p - '0';
      p++;
    }
    else
    {
      scale = default_oct;
    }

    scale += OCTAVE_OFFSET;

    if(*p == ',')
      p++;       // skip comma for next note (or we may be at the end)

    // now play the note

    if(note)
    {
       
      printf("Playing: \n");

      /*
      aDSP->setParamValue("/elecGuitar/midi/freq",freqs[(scale-4) * 12 + note]);
      aDSP->setParamValue("/elecGuitar/gate",1);
     */
/* 
      aDSP->setParamValue("/simpleSynt_Analog/freq",freqs[(scale-4) * 12 + note]);
      aDSP->setParamValue("/simpleSynt_Analog/gate",1);     
*/

      aDSP->setVoiceParamValue("/WaveSynth_FX/freq",voiceAddress,freqs[(scale-4) * 12 + note]);
      aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,1); 

      
      vTaskDelay(duration / portTICK_PERIOD_MS);
      //printf("%s \n",DSP->getJSONUI());
      //DSP->setParamValue("gain",0);
      //aDSP->setParamValue("/simpleSynt_Analog/gate",0); 
      // aDSP->setParamValue("/elecGuitar/gate",0);
      aDSP->setVoiceParamValue("/WaveSynth_FX/gate",voiceAddress,0); 
     // tone1.play(notes[(scale - 4) * 12 + note]);
      
      update_controls(voiceAddress,aDSP);  //later do this in a freertos task 
      
      //delay(duration);
      //tone1.stop();
      
    }
    else
    {
      //Serial.print("Pausing: ");
      //Serial.println(duration, 10);
      vTaskDelay(5*duration/ portTICK_PERIOD_MS);
    }
  }  //while (p*)
  } //song player    
 


void play_mono_rtttl(char *p, DspFaust * aDSP)
{
 // aDSP->allNotesOff();  
  aDSP->setParamValue("/WaveSynth_FX/lfoFreq",lfoFreq);
  aDSP->setParamValue("/WaveSynth_FX/lfoDepth",lfoDepth); 
  aDSP->setParamValue("/WaveSynth_FX/A",synthA);
  aDSP->setParamValue("/WaveSynth_FX/D",synthD); 
  aDSP->setParamValue("/WaveSynth_FX/S",synthS); 
  aDSP->setParamValue("/WaveSynth_FX/R",synthR); 
  // Absolutely no error checking in here
  unsigned char default_dur = 4;
  unsigned char default_oct = 6;
  int bpm = 63;
  int num;
  long wholenote;
  long duration;
  unsigned char note;
  unsigned char scale;

  // format: d=N,o=N,b=NNN:
  // find the start (skip name, etc)

  //char * p = song;

  while(*p != ':') p++;    // ignore name
  p++;                     // skip ':'

  // get default duration
  if(*p == 'd')
  {
    p++; p++;              // skip "d="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    if(num > 0) default_dur = num;
    p++;                   // skip comma
  }

 //Serial.print("ddur: "); Serial.println(default_dur, 10);

  // get default octave
  if(*p == 'o')
  {
    p++; p++;              // skip "o="
    num = *p++ - '0';
    if(num >= 3 && num <=7) default_oct = num;
    p++;                   // skip comma
  }

  //Serial.print("doct: "); Serial.println(default_oct, 10);

  // get BPM
  if(*p == 'b')
  {
    p++; p++;              // skip "b="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    bpm = num;
    p++;                   // skip colon
  }

  //Serial.print("bpm: "); Serial.println(bpm, 10);

  // BPM usually expresses the number of quarter notes per minute
  wholenote = (60 * 1000L / bpm) * 4;  // this is the time for whole note (in milliseconds)

  //Serial.print("wn: "); Serial.println(wholenote, 10);


  // now begin note loop
  while(*p)
  {
    // first, get note duration, if available
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    
    if(num) duration = wholenote / num;
    else duration = wholenote / default_dur;  // we will need to check if we are a dotted note after

    // now get the note
    note = 0;

    switch(*p)
    {
      case 'c':
        note = 1;
        break;
      case 'd':
        note = 3;
        break;
      case 'e':
        note = 5;
        break;
      case 'f':
        note = 6;
        break;
      case 'g':
        note = 8;
        break;
      case 'a':
        note = 10;
        break;
      case 'b':
        note = 12;
        break;
      case 'p':
      default:
        note = 0;
    }
    p++;

    // now, get optional '#' sharp
    if(*p == '#')
    {
      note++;
      p++;
    }

    // now, get optional '.' dotted note
    if(*p == '.')
    {
      duration += duration/2;
      p++;
    }
  
    // now, get scale
    if(isdigit(*p))
    {
      scale = *p - '0';
      p++;
    }
    else
    {
      scale = default_oct;
    }

    scale += OCTAVE_OFFSET;

    if(*p == ',')
      p++;       // skip comma for next note (or we may be at the end)

    // now play the note

    if(note)
    {
       
   //   Serial.print("Playing: ");
   //   Serial.print(scale, 10); Serial.print(' ');
   //   Serial.print(note, 10); Serial.print(" (");
   //   Serial.print(notes[(scale - 4) * 12 + note], 10);
   //   Serial.print(") ");
   //   Serial.println(duration, 10);
      /*
      aDSP->setParamValue("/elecGuitar/midi/freq",freqs[(scale-4) * 12 + note]);
      aDSP->setParamValue("/elecGuitar/gate",1);
     */
/* 
      aDSP->setParamValue("/simpleSynt_Analog/freq",freqs[(scale-4) * 12 + note]);
      aDSP->setParamValue("/simpleSynt_Analog/gate",1);     
*/

      aDSP->setParamValue("/WaveSynth_FX/freq",freqs[(scale-4) * 12 + note]);
      aDSP->setParamValue("/WaveSynth_FX/gate",1); 

      
      vTaskDelay(duration / portTICK_PERIOD_MS);
      //printf("%s \n",DSP->getJSONUI());
      //DSP->setParamValue("gain",0);
    //  aDSP->setParamValue("/simpleSynt_Analog/gate",0); 
        // aDSP->setParamValue("/elecGuitar/gate",0);
        aDSP->setParamValue("/WaveSynth_FX/gate",0); 
     // tone1.play(notes[(scale - 4) * 12 + note]);
      
      update_controls(0,aDSP);  //later do this in a freertos task 
      
      //delay(duration);
      //tone1.stop();
      
    }
    else
    {
      //Serial.print("Pausing: ");
      //Serial.println(duration, 10);
      vTaskDelay(5*duration/ portTICK_PERIOD_MS);
    }
  }  //while (p*)
  } //song player    
 
